<!DOCTYPE html>
<html xml:lang="en-us" lang="en-us">
    <head>
        




        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta property="og:site_name" content="Oracle Help Center">

        <!-- The title values -->
        <title></title>
        <meta property="og:title" content="">
        <meta name="application-name" content="GraalVM Community">
        <meta name="dcterms.title" content="">
        <!-- The description values -->
        
        
        
        <meta name="dcterms.created" content="2020-09-28T15:32:58+00:00">
        <meta name="dcterms.category" content="">
        <meta name="dcterms.identifier" content="">
        <meta name="dcterms.product" content="">
        <meta name="dcterms.isVersionOf" content="">

        <link rel="prev" href="/en/graalvm/enterprise/20/docs/reference-manual/enterprise-native-image/" title="Previous" type="text/html">
        <link rel="next" href="/en/graalvm/enterprise/20/docs/reference-manual/graalvm-updater/" title="Next" type="text/html">
        <link rel="first" href="/main.html" title="First Page" type="text/html">
        <link rel="contents" href="/toc.htm" title="Table of Contents" type="text/html">
        <link rel="self" href="/reference-manual/compiler/" title="Current Page" type="text/html">

        <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
        <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
        <meta name="robots" content="all">
        <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
        <script>
            document.write('<style type="text/css">');
            document.write('body > .noscript, body > .noscript ~ * { opacity: 0; }');
            document.write('</style>');
        </script>
        <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
        <script>
            if (window.require === undefined) {
                document.write('<script data-main="../../sp_common/book-template/ohc-book-template/js/book-config" src="../../sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="../../sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet">');
            }
        </script>
    </head>
    <body>
        <div class="noscript alert alert-danger text-center" role="alert">
            <a href="/en/graalvm/enterprise/20/docs/reference-manual/enterprise-native-image/" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
            <a href="/en/graalvm/enterprise/20/docs/reference-manual/graalvm-updater/" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
            <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        </div>
        <article>
            <h1 id="graalvm-compiler">GraalVM Compiler</h1>

<ul>
  <li><a href="#compiler-advantages">Compiler Advantages</a></li>
  <li><a href="#graph-compilation">Graph Compilation</a></li>
  <li><a href="#ahead-of-time-compilation">Ahead-of-time Compilation</a></li>
  <li><a href="#compiler-operating-modes">Compiler Operating Modes</a></li>
  <li><a href="#diagnostic-data">Diagnostic Data</a></li>
</ul>

<p>The GraalVM compiler is a dynamic just-in-time (JIT) compiler, written in Java,
that transforms bytecode into machine code. The GraalVM compiler integrates with
Java HotSpot VM that supports a compatible version of the JVM Compiler Interface
(JVMCI). JVMCI is a privileged low-level interface to the JVM, enabling a
compiler written in Java to be used by the JVM as a dynamic compiler (see <a href="https://openjdk.java.net/jeps/243">JEP 243</a>. It can read metadata from the VM, such
as method bytecode, and install machine code into the VM . GraalVM Enterprise includes a
version of the HotSpot JVM that supports JVMCI.</p>

<p><img src="/img/jvm-runtime-model.png" alt="" /></p>

<h2 id="compiler-advantages">Compiler Advantages</h2>

<p>The GraalVM compiler provides optimized performance for programs running on the
JVM through unique approaches to code analysis and optimization. The GraalVM
Enterprise compiler includes 62 separate compiler optimization algorithms
(called “Phases”), of which 27 are patented. Compiler phases including
aggressive inlining, polymorphic inlining, and other techniques make code more
efficient.</p>

<p>The GraalVM compiler assures performance advantages for highly abstracted
programs due to its ability to remove costly object allocations. Code using more
abstraction and modern Java features like Streams or Lambdas will see greater speedups. Low level code or code that converge to things like I/O, memory allocation, or garbage collection will
see less improvement. Consequently, an application running on
GraalVM Enterprise needs to spend less time doing memory management
and garbage collection. For more information on performance tuning, refer to
<a href="/en/graalvm/enterprise/20/docs/reference-manual/jvm/Options/">compiler configuration options</a>.</p>

<h2 id="graph-compilation">Graph Compilation</h2>

<p>To run guest programming languages, namely JavaScript, Ruby, R, Python, and
WebAssembly in the same runtime as the host JVM-based application, the GraalVM
compiler should work with a language-independent intermediate representation
(IR) between the source language and the machine code to be generated. A <em>graph</em>
was selected for this role.</p>

<p>The graph can represent similar statements of different languages, like “if”
statements or loops, in the same way, which makes it possible to mix languages
in the same program. The GraalVM compiler can perform then language-independent
optimization and generate machine code on this grpah.</p>

<p>GraalVM Enterprise includes the <a href="/en/graalvm/enterprise/20/docs/reference-manual/truffle-framework/">Language Implementation Framework</a>
– a library, written in Java, to build interpreters for programming languages,
which can then be executed in the GraalVM runtime. These languages, implemeneted
on top of this framework, can consequently benefit from the optimization
possibilities of the GraalVM compiler. The pipeline for such a compilation is:</p>

<ul>
  <li>The Language Implementation Framework code and data (Abstract Syntax Trees) is partially evaluated to
produce a compilation graph. When such an Abstract Syntax Tree (AST) is
hot (i.e., called many times), it is scheduled for compilation by the compiler.</li>
  <li>The compilation graph is optimized by the GraalVM compiler to produce machine code.</li>
  <li>JVMCI installs this machine code in the VM’s code cache.</li>
  <li>The AST will automatically redirect execution to the installed machine code once it is available.</li>
</ul>

<h2 id="ahead-of-time-compilation">Ahead-of-time Compilation</h2>

<p>GraalVM Enterprise also incorporates its optimizing compiler into an
advanced ahead-of-time (AOT) compiation technology – <a href="/en/graalvm/enterprise/20/docs/reference-manual/enterprise-native-image/">Native Image</a>, that translates Java and JVM-based
applications into native platform executables. These native executables start nearly instantaneously, are smaller, and consume less resources of the same Java
application, which makes them ideal for cloud deployments and
microservices. Continue reading to the <a href="/en/graalvm/enterprise/20/docs/reference-manual/enterprise-native-image/">Native Image</a> reference documentation.</p>

<h2 id="compiler-operating-modes">Compiler Operating Modes</h2>

<p>There are two operating modes of the GraalVM compiler when used as a HotSpot JIT
compiler: as pre-compiled machine code (“libgraal”), or as dynamically executed
Java bytecode (“jargraal”).</p>

<p><strong>libgraal:</strong> the GraalVM compiler is compiled ahead-of-time into a native shared library. In
this operating mode, the shared library is loaded by the HotSpot VM. The
compiler uses memory separate from the HotSpot heap and it runs fast from the
start since it does not need to warm-up. This is the default and recommended
mode of operation.</p>

<p><strong>jargraal:</strong> the GraalVM compiler goes through the same warm-up phase that the rest of Java
application does. That is, it is first interpreted before its hot methods are
compiled. This mode is selected with the <code>-XX:-UseJVMCINativeLibrary</code> command
line option.</p>

<h2 id="diagnostic-data">Diagnostic Data</h2>

<p>If an uncaught exception is thrown by the compiler, the compilation is simply
discarded and execution continues. However, the GraalVM compiler can instead produce
diagnostic data (such as compiler immediate representation graphs) that can be
submitted along with a bug report. This is enabled with
<code>-Dgraal.CompilationFailureAction=Diagnose</code>. The default location of the
diagnostics output is in <code>graal_dumps/</code> under the current working directory of
the process but can be changed with the <code>-Dgraal.DumpPath</code> option. During the VM
shutdown, the location of the archive containing the diagnostic data is printed
to the console.</p>

<p>Furthermore, diagnostic data can be produced for any compilation performed by
the GraalVM compiler with the <code>-Dgraal.Dump</code> option. This will produce
diagnostic data for every method compiled by the compiler. To refine the set of
methods for which diagnostic data is produced, use the
<code>-Dgraal.MethodFilter=&lt;class&gt;.&lt;method&gt;</code> option. For example,
<code>-Dgraal.MethodFilter=java.lang.String.*,HashMap.get</code> will produce diagnostic
data only for methods in the <code>java.lang.String</code> class as well as methods named
<code>get</code> in a class whose non-qualified name is <code>HashMap</code>.</p>

<p>Instead of being written to a file, diagnostic data can also be sent over the
network to <a href="/en/graalvm/enterprise/20/docs/tools/igv/">Ideal Graph Visualizer</a>.
This requires the <code>-Dgraal.PrintGraph=Network</code> option, upon which the compiler
will try to send diagnostic data to <em>127.0.0.1:4445</em>. This network endpoint can
be configured with the <code>-Dgraal.PrintGraphHost</code> and <code>-Dgraal.PrintGraphPort</code>
options.</p>

            
        </article>
    </body>
</html>
