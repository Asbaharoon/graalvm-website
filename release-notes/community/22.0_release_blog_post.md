
# GraalVM 22.0 is here!

Today we are releasing GraalVM 22.0! It brings new features and improvements throughout all components, and weâ€™ll talk about the highlights in this blog post.

## Get Updated

GraalVM 22.0 builds are available for JDK 11 and JDK 17.

As always, you can download GraalVM Community [from GitHub](https://github.com/graalvm/graalvm-ce-builds/releases), and get the GraalVM Enterprise builds [from OTN](https://www.oracle.com/downloads/graalvm-downloads.html).

For Docker deployments, use the following command to **get a Java 17 Enterprise image from the Oracle Container Registry** (assuming you are already logged into OCR using `docker login` and accepted the license):

```bash
docker pull container-registry.oracle.com/graalvm/jdk-ee:java17-22.0
```

and the following for a Community image:

```bash
docker pull ghcr.io/graalvm/jdk:java17-22.0
```

Container images for other supported Java versions are also available.

You can also install the latest version of GraalVM via the [GraalVM Extension Pack for Java](https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm-pack) in VS Code and with [Homebrew on macOS](https://github.com/graalvm/homebrew-tap).

Now, let's take a look at what's inside!

## Java and Compiler Updates

In this release, we significantly changed the way the GraalVM Enterprise compiler treats **profiling information**. The GraalVM compiler was designed as a highly-optimizing JIT compiler, which heavily relies on profiling information collected by the underlying runtime (HotSpot VM or Native Image). The profiles are used by the compiler to determine which code branches are executed most often, how frequently loops are executed, and which types are used in polymorphic code, to determine where to focus the optimization efforts. Therefore the quality of the profiles is critical to many optimizations such as inlining, duplication, vectorization, etc.
In this release, we have included support for the compiler to automatically switch to an AOT (ahead-of-time) mode, where major optimizations can still do a reasonable job even in the absence of profiles.
This helps Truffle languages that do not profile uncommon patterns that still can become hot, and in Native Image without profile-guided optimizations.
With this optimization in place, we observe performance improvements in GraalVM Enterprise of up to 25% for loop and type-check heavy benchmarks that lack good profiles.
This optimization is always enabled and cannot be disabled, as it is at the core of the compiler. It is transparent to the user and should provide general better code in the absence of precise branch and loop profiles.

A new **loop rotation optimization** now converts more uncounted loops to counted loops to benefit from optimizations like vectorization and partial unrolling. For workloads containing a lot of non-counted loops with a similar shape, loop rotation brings performance improvements of up to 30%.
This optimization is available in GraalVM Enterprise and is disabled by default in 22.0. To enable it, use the following flag: `-Dgraal.LoopRotation=true`. We plan to enable it by default in a future release.

In both Community and Enterprise editions, we added a new optimization to improve the **Native Image performance of a type switch** (i.e., a series of cascading `instanceof` branches). For example, for the following code:

```java
void foo(Object o) {
  if (o instanceof A) {
    // ...
  } else if (o instanceof B) {
    // ...
  } else if (o instanceof C) {
    // ...
  }
}
```
In Native Image, the compiler graph for this used to be:

```java
void foo(Object o) {
  if (o != null && A.class.isAssignableFrom(o.getClass())) {
    // ...
  } else if (o != null && B.class.isAssignableFrom(o.getClass())) {
    // ...
  } else if (o != null && C.class.isAssignableFrom(o.getClass())) {
    // ...
  }
}
```
With the new optimization, the null check and load of `o`'s class are factored out:

```java
void foo(Object o) {
  if (o != null) {
    Object nonNullO = o;
    Class oClass = nonNullO.getClass();
    if (A.class.isAssignableFrom(oClass)) {
      // ...
    } else if (B.class.isAssignableFrom(oClass) {
      // ...
    } else if (C.class.isAssignableFrom(oClass)) {
      // ...
    }
  }
}
```
One thing to keep in mind is that this optimization only pays off if there are subclasses of `A`, `B`, and `C` that Native Image sees as allocated. Otherwise, the `instanceof` tests are reduced to `==` comparisons on the class of `o`.

## Native Image

One of our key focus areas in Native Image is to improve the developer experience. We [significantly reduced image build times and memory usage](https://medium.com/graalvm/graalvm-21-3-is-here-java-17-native-image-performance-updates-and-more-ac4cbafcfc05#d243) over the past few releases. This work continued in 22.0, as we added updates to reduce image size: a more compressed encoding for stack frame metadata reduces image size for all images. In the Enterprise edition, this aspect was improved even further with an optimized implementation of `String.format()`, which makes localization classes unreachable for small images such as "Hello World" and significantly reduces the image size.
Another related update in this release is the [new build output](https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/BuildOutput.md) for Native Image. It breaks down the build process into stages such as initializing, performing analysis, and others and visualizes the current stage, shows code and heap breakdowns, statistics on reachability and other aspects of the build, RSS and CPU usage, and more. Here's an example:
```text
================================================================================
GraalVM Native Image: Generating 'helloworld'...
================================================================================
[1/7] Initializing...                                            (2.5s @ 0.21GB)
 Version info: 'GraalVM dev Java 11 CE'
[2/7] Performing analysis...  [*******]                          (5.6s @ 0.46GB)
   2,565 (82.61%) of  3,105 classes reachable
   3,216 (60.42%) of  5,323 fields reachable
  11,652 (72.44%) of 16,086 methods reachable
      27 classes,     0 fields, and   135 methods registered for reflection
      57 classes,    59 fields, and    51 methods registered for JNI access
[3/7] Building universe...                                       (0.5s @ 0.61GB)
[4/7] Parsing methods...      [*]                                (0.5s @ 0.86GB)
[5/7] Inlining methods...     [****]                             (0.5s @ 0.73GB)
[6/7] Compiling methods...    [**]                               (3.7s @ 2.38GB)
[7/7] Creating image...                                          (2.1s @ 1.04GB)
   3.69MB (27.19%) for code area:    6,955 compilation units
   5.86MB (43.18%) for image heap:   1,545 classes and 80,528 objects
   3.05MB (22.46%) for debug info generated in 1.0s
 997.25KB ( 7.18%) for other data
  13.57MB in total
--------------------------------------------------------------------------------
Top 10 packages in code area:           Top 10 object types in image heap:
 606.23KB java.util                        1.64MB byte[] for general heap data
 282.34KB java.lang                      715.56KB java.lang.String
 222.47KB java.util.regex                549.46KB java.lang.Class
 219.55KB java.text                      451.79KB byte[] for java.lang.String
 193.17KB com.oracle.svm.jni             363.23KB java.util.HashMap$Node
 149.80KB java.util.concurrent           192.00KB java.util.HashMap$Node[]
 118.07KB java.math                      139.83KB java.lang.String[]
 103.60KB com.oracle.svm.core.reflect    139.04KB char[]
  97.83KB sun.text.normalizer            130.59KB j.u.c.ConcurrentHashMap$Node
  88.78KB c.oracle.svm.core.genscavenge  103.92KB s.u.l.LocaleObjec~e$CacheEntry
      ... 111 additional packages             ... 723 additional object types
                       (use GraalVM Dashboard to see all)
--------------------------------------------------------------------------------
    0.9s (5.6% of total time) in 17 GCs | Peak RSS: 3.22GB | CPU load: 10.87
--------------------------------------------------------------------------------
Produced artifacts:
 /home/janedoe/helloworld/helloworld (executable)
 /home/janedoe/helloworld/sources (debug_info)
 /home/janedoe/helloworld/helloworld (debug_info)
 /home/janedoe/helloworld/helloworld.build_artifacts.txt
================================================================================
Finished generating 'helloworld' in 16.2s.
```
This feature is enabled by default, so take it for a spin and tell us what you think! 
If you rely on the previous build output, you can switch to it by using `-H:-BuildOutputUseNewStyle`.
Please note that the previous output style is deprecated and will be removed in a future release.

Another update is related to the memory requirements of native executables. The new garbage collection policy for the Serial Garbage Collector (Serial GC), [introduced in 21.3](https://medium.com/graalvm/graalvm-21-3-is-here-java-17-native-image-performance-updates-and-more-ac4cbafcfc05#52a9), is now enabled by default. It reduces the max RSS size of native executables by up to 30%. For a typical microservices workload such as Spring Petclinic, we measured peak throughput improvements of up to 23.22%.
Another feature introduced in 21.3, and extended in this release, is support for the Java Platform Module System. In particular, Native Image now supports the  `--add-reads` and `--add-modules` options. Also, all module-related options such as `--add-reads`, `--add-exports`, and `--add-opens` are now applied before scanning the classpath/module-path. This ensures the modules are properly configured before class loading, which avoids class loading errors. Also, more information about modules is added to the image heap, which allows more module introspection at run time.
GraalVM [Native Build Tools](https://graalvm.github.io/native-build-tools/latest/index.html) added several improvements over the past few releases, such as the improved integration with the native agent. Get [the latest release from GitHub](https://github.com/graalvm/native-build-tools/releases/tag/0.9.9).
Speaking of the latest releases and features, we added support for reflective introspection of sealed classes in JDK 17: `Class.isSealed()` and `Class.getPermittedSubclasses()`.
Note that as part of this release, we removed the option `-H:SubstitutionFiles=...` to register substitutions via a JSON file.


## GitHub Action for GraalVM

Recently we released an official [GitHub action for GraalVM](https://github.com/marketplace/actions/github-action-for-graalvm) that makes it easy to set up and use GraalVM Community Edition, Native Image, and Truffle languages and tools in your GitHub Actions workflows. Thanks to the community for providing [feedback on this](https://github.com/oracle/graal/discussions/4150) and for [sharing](https://twitter.com/helpermethod/status/1477967455469412355) their excitement on [Twitter](https://twitter.com/DeLaGuardo/status/1479028462249816065)! 

https://twitter.com/juliendubois/status/1478313659969462282 // this will be embedded on Medium and will look better this way


The new action exports `$GRAALVM_HOME` and sets `$JAVA_HOME` accordingly, so you can use GraalVM to build, test, and deploy your apps. The action also extends `$PATH` so you can directly invoke Truffle languages and tools, and it sets up build environments according to the selected components, allowing you, for example, to generate native images without any additional steps. Here's an example of how you can use the new action in your workflows:
```yml
steps:
  - uses: actions/checkout@v2
  - uses: graalvm/setup-graalvm@v1
    with:
      version: '22.0.0'
      java-version: '17'
      components: 'native-image'
      github-token: ${{ secrets.GITHUB_TOKEN }}
  - name: Example step
    run: |
      echo "GRAALVM_HOME: $GRAALVM_HOME"
      echo "JAVA_HOME: $JAVA_HOME"
      java --version
      native-image --version
```
For additional templates, a list of all features and options, and more information, check out the GitHub Action for GraalVM at https://github.com/marketplace/actions/github-action-for-graalvm, and feel free to provide feedback or request features on the corresponding [`setup-graalvm` repository](https://github.com/graalvm/setup-graalvm).


## Polyglot Runtime and Embedding

In GraalVM Enterprise, we introduced **polyglot isolates**, which which along with a number of other features enable heap isolation between the host and guest applications. Using isolates improves the security, startup, and warmup time of Truffle languages. You can create an isolate for for a Context (Engine) by calling  by calling `Context.Builder.option("engine.SpawnIsolate", "true")`. In this mode, calls between host and guest are more costly as they need to cross a native boundary. It is recommended to use the `HostAccess.SCOPED` policy with this mode to avoid strong cyclic references between host and guest. Note that this mode is experimental in this release and only supported for JavaScript; we plan to extend support in future releases.

We also enabled [Auxiliary Engine Caching](https://github.com/oracle/graal/blob/master/truffle/docs/AuxiliaryEngineCachingEnterprise.md) in JavaScript and Node in native mode. Engine Caching is intended to eliminate the warmup of programs running on Truffle languages, which comes from operations such as loading, parsing, profiling, and compilation. Within a single OS process, the work performed during warmup can be shared with in-process engine caching. Auxiliary engine caching builds upon this mechanism but adds the capability to persist a code snapshot with ASTs and optimized machine code to disk. This way, even for the first execution of the guest application the warmup can be significantly reduced.

### Truffle Language and Tool Implementations

An important update in this release is the introduction of sharing layers. A sharing layer is a set of language instances that share code within one or more polyglot contexts. In previous versions, language instances were shared individually whenever a new language context was created. Instead, language instances are now reused for a new context if and only if the entire layer can be shared. A layer can be shared if all initialized languages of the layer support the same context policy and their options are compatible.

Previously, different Truffle languages may have used different mechanisms for exiting. This wasn't optimal, as a Truffle language had no way to detect and handle an exit triggered by a different language. As of 22.0, Truffle has support for polyglot context hard explicit exit, triggered by guest languages using TruffleContext.closeExited(Node,int). It provides a unified way for languages to trigger the exit of the underlying polyglot context. When triggered, all initialized guest languages are first notified using TruffleLanguage.exitContext(C,ExitMode,int), then all context threads are stopped, and finally, the context is closed. The hard explicit exit is simply referred to as "hard exit".

New APIs were also added to `com.oracle.truffle.api.frame.Frame` and `com.oracle.truffle.api.frame.FrameDescriptor`, learn more about these changes in the project [changelog](https://github.com/oracle/graal/blob/master/truffle/CHANGELOG.md#version-2200).

## JavaScript

In this release of the GraalVM JavaScript runtime, we enabled ECMAScript 2022 mode by default. We implemented several new proposals, such as `Intl.DisplayNames v2`, `Intl Locale Info`, `Intl.DateTimeFormat.prototype.formatRange`, `Extend TimeZoneName Option`, `Intl Enumeration API`, which you can use with corresponding flags. Also, the Node.js runtime was updated to version 14.18.1.

## Python

We keep working on the compatibility of the GraalVM Python runtime and extending module support. In this release, we added support for the `pyexpat` and `_csv` modules, and improved compatibility with the `wheel` and `click` PyPI packages.

## Ruby

This release adds support for Ruby 3.0 (see [this GitHub issue](https://github.com/oracle/truffleruby/issues/2453)). Most of the Ruby 3 changes are implemented in this release, with the exception of Ractor, parser changes, and keyword arguments changes.

We also added several optimizations to make the interpreter faster, improving application performance before the code is JIT-compiled. Just recently we published a blog post comparing the performance of TruffleRuby and other Ruby implementations, so if you are working with Ruby, make sure to check it out: https://medium.com/graalvm/benchmarking-cruby-mjit-yjit-jruby-and-truffleruby-6a7178ca6906.

## FastR

In this release, we kept working on compatibility and package support. We also adopted Truffle's [NodeLibrary](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/NodeLibrary.html), which provides access to guest language information associated with a particular Node location.

## Java on Truffle

Exactly one year ago we [introduced](https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840) Java on Truffle. Itâ€™s come a long way since â€” we added new features, improved startup and peak performance, and saw a lot of interest from the community.

We also added support for running native code with the [GraalVM LLVM runtime](https://www.graalvm.org/reference-manual/llvm/).

Also, in this release we extended class redefinition functionality â€” in particular, we added support for changes to fields and class access modifiers.

## WebAssembly

Along with compatibility and performance work, the WebAssembly runtime adopted the new [Truffle Frame API](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/frame/Frame.html).

## LLVM Runtime

There were several improvements and fixes that went into this release. In particular, loop count profiles are now also reported in first-tier compiled code, improving warmup by transitioning from first-tier to second-tier compilation sooner for loop-heavy methods.

## Tools

In this release, we've made several changes to the developer experience of the [GraalVM Extension Pack for Java](https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm-pack) for VS Code. In particular, we added the ability to manage GraalVM installations with [SDKMan](https://sdkman.io/), provided a graphical UI for the change method signature refactoring, and added the Project View for Gradle and Maven projects.

*Project Explorer UI*

You can now customize Run Configuration parameters such as program arguments, VM options, and environment variables. For more advanced scenarios, you can set configuration via `launch.json`.

Also, VisualVM added preliminary support for JDK 18 and [exact thread state monitoring](https://github.com/oracle/visualvm/issues/363) via JFR events.

 ![](../img/VisualVM_threads_monitoring.png)

 *exact thread state monitoring in VisualVM*


## Conclusion

With all updates that went into this release, now is a great time to update your GraalVM installations â€” you can get new builds for both GraalVM [Enterprise](https://www.oracle.com/downloads/graalvm-downloads.html) and [Community](http://graalvm.org/downloads).

We are grateful to the community for all the feedback, suggestions, and contributions that went into this release. If you have additional feedback on this release, or suggestions for features that you would like to see in future features, please share it with us on [Slack](https://graalvm.org/slack-invitation), [GitHub](https://github.com/oracle/graal), or [Twitter](https://twitter.com/graalvm).

â€” the GraalVM team
