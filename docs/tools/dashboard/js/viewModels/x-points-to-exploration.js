define(["knockout","app/util","app/debug","app/pointstograph-layout","ojs/ojarraydataprovider","ojs/ojattributegrouphandler","ojs/ojdiagram","ojs/ojknockout"],(function(e,t,o,s,a,i){class n{stringify(){throw new TypeError("PointsToReason is abstract.")}toString(){return this.stringify()}}class r extends n{stringify(){return"EntryPointReason()"}}class c extends n{constructor(e){super(),this.className=e}stringify(){return`TypeReason(${this.className})`}}class l{constructor(e){this._shortened=e}className(e){return this._shortened?t.simplifyQualifiedName(e,0):e}_fieldOrMethodName(e){return this._shortened?t.simplifyQualifiedName(e,1):e}fieldName(e){return this._fieldOrMethodName(e)}methodName(e){return this._fieldOrMethodName(e)}static extractClassName(e){let t=e.indexOf("("),o=e.substring(0,t);return t=o.lastIndexOf("."),o.substring(0,t)}}class d{constructor(e,t){this._graph=e,this.pointsToGraph=t,this.explorationNodes={},this.explorationEdges={},this.explorationDegrees={}}createExploredNode(e,t){const o=this._createNode(e,t,!0);return this._createUnexploredNeighbours(o,t),o}exploreNode(e){const o=this.explorationNodes[e];if(o.isExplored()){const e=o.pointstoNode.info.codeLocation;e&&t.openOrDownloadFile([e],"sourceline.gds","graalvm/dashboard/pointto-sourceline")}else o.isExplored(!0),this._createUnexploredNeighbours(o,o.reason)}_createNode(e,t,o,s){const a=class{static explorationId(e,t){return`${e}@${t.stringify()}`}}.explorationId(e,t);null==s&&null==(s=this.explorationDegrees[a])&&(s=0),void 0!==this.explorationDegrees[a]&&null!=this.explorationDegrees[a]||(this.explorationDegrees[a]=s);const i=this.explorationNodes[a];if(i)return i;const n=this.pointsToGraph[e],r=new p(a,n,this.pointsToGraph,t,o);return this.explorationNodes[a]=r,this._graph.nodes.push(r.forUI()),r}_createEdge(e,t,o){const s=new h(e,t,o),a=this.explorationEdges[s.id];return a||(this.explorationEdges[s.id]=s,this._graph.links.push(s.forUI()),s)}_createUnexploredNeighbours(e,t){const o=this.explorationDegrees[e.id]+1;switch(0!==o&&1!==o&&console.log(),e.pointstoNode.flowType){case"method":switch(t.constructor.name){case r.prototype.constructor.name:e.pointstoNode.info.inputs.forEach(t=>{const s=this.pointsToGraph[t];if(null==s)return void console.debug("Node with ID "+t+"not found,  was input to "+e.pointstoNode.id);const a=s.flowType,i=new c(l.extractClassName(e.pointstoNode.info.qualifiedName));if("callsite"===a){const t=this._createNode(s.id,i,!1,o);this._createEdge(e,t,i)}else console.debug("Unexpected input flow type, method: "+a)})}break;case"callsite":e.pointstoNode.info.inputs.forEach(s=>{const a=this.pointsToGraph[s];if(null!=a)switch(a.flowType){case"instanceFieldLoad":case"staticFieldLoad":{const s=this._createNode(a.id,t,!1,o);this._createEdge(e,s,t);break}case"method":{const t=new r,s=this._createNode(a.id,t,!1,o);this._createEdge(e,s,t);break}case"nullCheck":{const s=this._createNode(a.id,t,!1,o);this._createEdge(e,s,t);break}case"dynamicAlloc":case"alloc":{const s=this._createNode(a.id,t,!1,o);this._createEdge(e,s,t);break}default:console.debug("Unexpected input flow type: "+a.flowType)}else console.debug("Node with ID "+s+"not found,  was input to "+e.pointstoNode.id)});break;case"dynamicAlloc":case"alloc":e.pointstoNode.info.inputs.forEach(s=>{const a=this.pointsToGraph[s],i="method"===a.flowType?new r:t,n=this._createNode(a.id,i,!1,o);this._createEdge(e,n,i)});break;case"field":e.pointstoNode.info.inputs.forEach(s=>{const a=this.pointsToGraph[s];if(null!=a)switch(a.flowType){case"instanceFieldStore":case"staticFieldStore":if(a.info.types.includes(t.className)){const s=this._createNode(a.id,t,!1,o);this._createEdge(e,s,t)}break;default:console.debug("Unexpected input flow type: "+a.flowType)}else console.debug("Node with ID "+s+"not found,  was input to "+e.pointstoNode.id)});break;case"instanceFieldStore":case"staticFieldStore":case"instanceFieldLoad":case"staticFieldLoad":e.pointstoNode.info.inputs.forEach(s=>{const a=this.pointsToGraph[s];let i=t;"formalReceiver"===a.flowType&&(i=new c(a.info.qualifiedName));const n=this._createNode(a.id,i,!1,o);this._createEdge(e,n,i)});break;case"formalParam":case"actualParam":case"actualReturn":case"formalReturn":case"atomicRead":case"atomicWrite":case"nullCheck":case"arrayCopy":case"box":case"clone":case"compareAndSwap":case"filter":case"formalReceiver":case"instanceOf":case"loadIndexed":case"monitorEnter":case"proxy":case"source":case"storeIndexed":case"unsafeLoad":case"unsafeStore":this._exploreAllNeighborsCanonical(e,t,o);break;case"merge":this._exploreRelevantNeighborsCanonical(e,t,o);break;default:console.debug("Unknown flow type "+e.pointstoNode.flowType)}}_exploreAllNeighborsCanonical(e,t,o){e.pointstoNode.info.inputs.forEach(s=>{const a=this.pointsToGraph[s],i=this._createNode(a.id,t,!1,o);this._createEdge(e,i,t)})}_exploreRelevantNeighborsCanonical(e,t,o){e.pointstoNode.info.inputs.forEach(s=>{const a=this.pointsToGraph[s];if(void 0===a.info.types&&console.debug("Ignoring "+a.flowType+" node - does not have a type state."),a.info.types.includes(t.className)){const s=this._createNode(a.id,t,!1,o);this._createEdge(e,s,t)}})}}class p{constructor(t,s,a,i,n){this.id=t,this.pointstoNode=s,this.pointsToGraph=a,this.reason=i,this.isExplored=e.observable(n),this.shortLabel=f.createNodeLabel(this,!0),this.longLabel=f.createNodeLabel(this,!1),(o.showCodeLocationForAllTypes()||o.showCodeLocationForTypes().includes(s.flowType))&&null!=s.info.codeLocation&&(this.longLabel+=`\n(${s.info.codeLocation})`),o.showPointstoNodeIds()&&o.showExplorationNodeIds()?this.label+=` (ptId=${s.id}, expId=${t})`:o.showPointstoNodeIds()?this.label+=` (ptId=${s.id})`:o.showExplorationNodeIds()&&(this.label+=` (expId=${t})`)}forUI(){return{id:this.id,label:this.shortLabel,longLabel:this.longLabel,category:e.computed(function(){return this.isExplored()?"0":"1"}.bind(this))}}}class h{constructor(e,t,s){this.id=`${e.id}-${t.id}`,this.source=e.id,this.target=t.id,this.reason=s,this.longLabel=f.createEdgeLabel(e,t,s,!1),this.shortLabel=f.createEdgeLabel(e,t,s,!0),o.showEdgeLabels()||(this.shortLabel=""),o.showEdgeLabels()&&o.edgeLabelsReasonOnly()&&(this.shortLabel=this.reason.stringify()),this.type=f.findEdgeType(e,t)}forUI(){return{id:this.id,start:this.source,end:this.target,longLabel:"string"==typeof this.longLabel?this.longLabel:this.longLabel.stringify(),category:"0"}}}const u={CALLER:0,RECEIVER:1,TYPE:2,FIELD:3};Object.freeze(u);class f{static createNodeLabel(e,o){const s=new l(o),a=e.pointstoNode;switch(a.flowType){case"method":return"Method "+s.methodName(a.info.qualifiedName);case"callsite":{const o=t.findRelevantCallee(a,e.reason);return console.assert(null!=o,"Callsite should have callee matching reason type."),e.relevantCalleeName=o,`Call to ${s.methodName(o)} occurred`}case"instanceFieldLoad":case"staticFieldLoad":return`Type ${s.className(e.reason.className)} was loaded from field ${s.fieldName(a.info.qualifiedName)}`;case"field":return`Field ${s.fieldName(a.info.qualifiedName)} can have type ${s.className(e.reason.className)}`;case"instanceFieldStore":case"staticFieldStore":return`Type ${s.className(e.reason.className)} can be stored to field ${s.fieldName(a.info.qualifiedName)}`;case"formalParam":{const t=e.pointsToGraph[a.info.enclosingMethod];return`Method ${s.methodName(t)} can receive ${s.className(e.reason.className)} as parameter`}case"actualParam":return`Type ${s.className(e.reason.className)} can be passed to a method`;case"formalReturn":{const t=e.pointsToGraph[a.info.enclosingMethod].info.qualifiedName;return`Method ${s.methodName(t)} can return ${s.className(e.reason.className)}`}case"actualReturn":return"A method call can return "+s.className(e.reason.className);case"dynamicAlloc":case"alloc":return`Type ${s.className(e.reason.className)} gets allocated`;case"nullCheck":return"null check";case"formalReceiver":return"The receiver is "+s.className(a.info.qualifiedName);case"merge":return"merge";default:return console.debug("Unexpected flow type: "+a.flowType),a.flowType}}static findEdgeType(e,t){switch(e.pointstoNode.flowType){case"method":return u.CALLER;case"callsite":switch(t.pointstoNode.flowType){case"method":return u.CALLER;default:return u.RECEIVER}case"instanceFieldLoad":case"staticFieldLoad":switch(t.pointstoNode.flowType){case"field":return u.FIELD;default:return u.RECEIVER}case"instanceFieldStore":case"staticFieldStore":switch(t.pointstoNode.flowType){case"formalReceiver":return u.RECEIVER;default:return u.TYPE}default:return u.TYPE}}static createEdgeLabel(e,o,s,a){const i=new l(a);switch(s.constructor.name){case r.prototype.constructor.name:switch(e.pointstoNode.flowType){case"callsite":switch(o.pointstoNode.flowType){case"method":return`Where does callsite of ${i.className(e.relevantCalleeName)} happen?`;default:return console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s}case"dynamicAlloc":case"alloc":switch(o.pointstoNode.flowType){case"method":case"callsite":return"Where does alloc happen?";case"formalReturn":case"formalReceiver":return"Where does allocated value go?";default:return console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s}case"instanceFieldLoad":case"staticFieldLoad":case"nullCheck":return o.pointstoNode.flowType,console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s;case"formalReceiver":return"Where does receiver come from?";case"formalReturn":return"Where does return value come from?";default:return console.debug("Unexpected source flow type: "+e.pointstoNode.flowType),s}case c.prototype.constructor.name:switch(e.pointstoNode.flowType){case"method":switch(o.pointstoNode.flowType){case"callsite":return`Why is method ${i.className(e.pointstoNode.info.qualifiedName)} included?`;default:return console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s}case"callsite":{const o=e.pointstoNode.info.calleeNames[0];return`Why is receiver of ${t.extractMethodName(o)} ${i.className(s.className)}?`}case"instanceFieldLoad":case"staticFieldLoad":switch(o.pointstoNode.flowType){case"field":return`Why can ${i.className(s.className)} be loaded from ${i.fieldName(o.pointstoNode.info.qualifiedName)}?`;case"formalReceiver":return"Who is the receiver of this load?";default:return console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s}case"field":switch(o.pointstoNode.flowType){case"instanceFieldStore":case"staticFieldStore":return`Why can ${i.fieldName(e.pointstoNode.info.qualifiedName)} have type ${i.className(s.className)}?`;default:return console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s}case"instanceFieldStore":case"staticFieldStore":switch(o.pointstoNode.flowType){case"formalReceiver":return"Who is the receiver of this store?";default:return`Why can this store have type ${i.className(s.className)}?`}case"formalReturn":o.pointstoNode.flowType;{const t=e.pointstoNode.info.enclosingMethod,o=e.pointsToGraph[t].info.qualifiedName;return`Why can ${i.methodName(o)} return ${i.className(s.className)}?`}case"actualReturn":switch(o.pointstoNode.flowType){case"formalReturn":return`Why can type ${i.className(s.className)} be returned?`;default:return console.debug("Unexpected target flow type: "+o.pointstoNode.flowType),s}case"formalParam":case"actualParam":return o.pointstoNode.flowType,`Where can param be ${i.className(s.className)}?`;case"merge":return o.pointstoNode.flowType,`Which branches can be ${i.className(s.className)}?`;case"nullCheck":return o.pointstoNode.flowType,"Where does checked value come from?";case"formalReceiver":return`Why is the receiver ${i.className(e.pointstoNode.info.qualifiedName)}?`;default:return console.debug("Unexpected source flow type: "+e.pointstoNode.flowType),s}default:return console.debug("Unexpected reason: "+s.constructor.name),s}}}return function(t){const o={nodes:e.observableArray(),links:e.observableArray()},n=t.tile.contextualData.entryPointName,c=n?t.tile.section.methodNameIndex[n]:void 0,l=new d(o,t.tile.section.pointsToGraph);l.createExploredNode(c,new r),this.id="points-to-exploration-"+t.tile.id,this.layoutFunc=function(e){s.layout(e,l.explorationDegrees)},this.colorHandler=new i.ColorAttributeGroupHandler,this.nodeDataProvider=new a(o.nodes,{keyAttributes:"id"}),this.linkDataProvider=new a(o.links,{keyAttributes:"id"}),this.selectedNode=e.observable(),this.selectedNode.subscribe(function(e){e&&e.length>0&&(l.exploreNode(e),setTimeout(()=>this.selectedNode([]),1e3))}.bind(this))}}));