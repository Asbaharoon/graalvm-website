define((function(){class t{constructor(t,e,r){this._isLeafNode=!1,this._parent=t,this._isGroup=!1,this.depth=e,this._value=0,this._cumulativeValue=0,this.isRoot=!1,this._children=new Map,this._childrenArray=[],void 0!==e&&void 0!==r&&this._createNode(e,r)}_createNode(t,e){this.name=0===t?"*":e[0].path[t-1],0===t?this.fullPath="*":t===e[0].path.length&&this.name.startsWith("(")?this.fullPath=`${this._parent.fullPath}${this.name}`:this.fullPath=`${this._parent.fullPath}.${this.name}`,this._appendChildren(e)}value(){return this._value}cumulativeValue(){return this._cumulativeValue}cumulativeValueAtDepth(t,e){return this.depth===t.currentViewRoot().depth+e||this.isLeafNode()?this._cumulativeValue:0}relativeCumulativeValue(t,e){void 0===e&&(e=!0);let r=this;for(let s=0;s<t;s++)if(r=e?r.nonGroupParent():r.parent(),null==r)return-1;return this.cumulativeValue()/r.cumulativeValue()}child(t){return this._children.has(t)?this._children.get(t):null}parent(){return this._parent}grandparent(){return null==this.parent()?null:this.parent().parent()}nonGroupParent(){let t=this.parent();for(;null!=t&&"group"===t._type;)t=t.parent();return console.assert(null!=t||this.isRoot),t}nonGroupGrandparent(){return null==this.nonGroupParent()?null:this.nonGroupParent().nonGroupParent()}children(){return this._childrenArray}childrenUpTo(t){return this.depth<t?this._childrenArray:[]}isGroup(){return this._isGroup}groupedChildren(t,e,r){return this.depth>=t.currentViewRoot().depth+e?[]:this._groupChildren(this._childrenArray,r,t.currentViewRoot()._cumulativeValue)}_groupChildren(t,r,s){if(t.length<3)return t;if(t.sort((t,e)=>t._cumulativeValue-e._cumulativeValue)[0]._cumulativeValue/s>=r)return t;let i=0;const h=[],n=[];t.forEach(t=>{t._cumulativeValue/s<r?(i+=t._cumulativeValue,h.push(t)):n.push(t)});const u=Math.max(n.length-1,0);let l=0;for(;l<u&&i/s<r;){const t=n[l];h.push(t),i+=t._cumulativeValue,l++}const a=[];for(;l<n.length;)a.push(n[l]),l++;if(a.length>0)return a.push(new e(this,h)),a;const o=[],c=[];for(l=0;l<h.length;)l%2==0?o.push(h[l]):c.push(t[l]),l++;return o.length>1?a.push(new e(this,o)):(console.assert(1===o.length,"Group must have exactly 1 element at this point."),a.push(o[0])),c.length>1?a.push(new e(this,c)):(console.assert(1===c.length,"Group must have exactly 1 element at this point."),a.push(c[0])),a}childrenNames(){return Array.from(this._children.keys())}getFullPath(){return this.fullPath}isLeafNode(){return this._isLeafNode}collectDescendants(t){this._children.forEach(e=>{e.collectDescendants(t),t.push(e)})}_appendChildren(e){if(e[0].path.length===this.depth)return console.assert(1===e.length),this._isLeafNode=!0,this._value=e[0].value,void this._accumulateValue(this._value);const r=new Map;e.forEach(t=>{const e=t.path[this.depth];r.has(e)||r.set(e,[]),r.get(e).push(t)}),r.forEach((e,r,s)=>{const i=new t(this,this.depth+1,e);this._children.set(r,i),this._childrenArray.push(i)})}_accumulateValue(t){this.isLeafNode()&&(console.assert(void 0===this._valueAccumulated),this._valueAccumulated=!0),this._cumulativeValue+=t,null!=this._parent&&this._parent._accumulateValue(t)}}class e extends t{constructor(t,e){super(t),this._isGroup=!0,this.members=e,this.depth=t.depth,this.memberNames=[],this.members.forEach(t=>{this._cumulativeValue+=t._cumulativeValue,this._value+=t._value,this.memberNames.push(t.name)}),this.name="{"+this.memberNames.join(", ")+"}";let r="";const s=this.members[0].fullPath.split(".");for(let t=0;t<s.length-1;t++)r+=s[t]+".";r+=this.name,this.fullPath=r}cumulativeValueAtDepth(t,e){return this._isViewRoot(t)?0:this._cumulativeValue}groupedChildren(t,e,r){return this._isViewRoot(t)?this._groupChildren(this.members,r,t.currentViewRoot()._cumulativeValue):[]}isLeafNode(){return!1}_isViewRoot(t){return this===t.currentViewRoot()}}return class{constructor(e){0!==e.length?(this.data=this._extractDataEntries(e),this._root=new t(null,0,this.data),this._root.isRoot=!0):console.err("Empty histogram, can't create data structure.")}root(){return this._root}findNode(t){const e=t.split(".");let r=this._root;return e.forEach(t=>{null!=r&&"*"!==t&&(r=r.child(t))}),r}children(t){void 0===t&&(t="");const e=this.findNode(t);return null==e?null:e.children()}childrenNames(t){if(void 0===t)return this._root.childrenNames();const e=this.findNode(t);return null==e?null:e.childrenNames()}descendants(t){const e=[];if(void 0===t)return this._root.collectDescendants(e),e;const r=this.findNode(t);return null==r?null:(r.collectDescendants(e),e)}_extractDataEntries(t){const e=[];return t.forEach(t=>{t instanceof Array?e.push({path:t[1],value:t[2]}):e.push({path:t.name.split("."),value:t.size})}),e}}}));