define(["knockout","app/util"],(function(t,e){"use strict";class r{constructor(t){this.reader=t.stream().getReader(),this.chunks=[],this.iters=[],this.readChunk=function(t){return t.done?(this.done(),Promise.resolve(t)):(this.chunks.push(t.value),this.updateIters(),Promise.resolve(t))}.bind(this),this.readRest=function(t){if(!t.done)return this.reader.read().then(this.readChunk).then(this.readRest)}.bind(this)}done(){this.reader.releaseLock();for(const t of this.iters)t.done();this.iters=void 0}updateIters(){const t=this.chunks.length;for(const e of this.iters)e.update(t)}async read(t,e){if(this.chunks.length>0){let r;if(this.chunks[0].length<e)throw new Error("Chunk is too small to read header of file.");return r=new s(this),t(r),Promise.resolve(r)}{let r;return this.readRest(await this.reader.read().then(this.readChunk).then(i=>{if(i.value.length<e)throw new Error("Chunk is too small to read header of file.");return r=new s(this),t(r),i})).then(()=>r)}}}class s{constructor(t){this.source=t,this.done=void 0===this.source.iters,this.done||this.source.iters.push({done:()=>this.done=!0,update:t=>this.maxChunk=t}),this.chunk=0,this.pos=0,this.curChunk=this.source.chunks[0],this.curLength=this.curChunk.length,this.maxChunk=this.source.chunks.length,this.view=new DataView(this.curChunk.buffer),this.views=[],this.views[4]=new DataView(new ArrayBuffer(4)),this.views[8]=new DataView(new ArrayBuffer(8))}loadTo(t,e,r){for(let e=0;e<r;++e)t.setUint8(e,this.next());this.nextChunk();for(let s=r;s<e;++s)t.setUint8(s,this.next());return t}chunkLeft(){return this.curLength-this.pos}chunksLeft(){return this.maxChunk-this.chunk}readable(t,e){return e<=t||this.chunksLeft()>1&&this.source.chunks[this.chunk+1].length+t>=e}available(t){return this.readable(this.chunkLeft(),t)}next(){return this.curChunk[this.pos++]}nextChunk(){this.curChunk=this.source.chunks[++this.chunk],this.curLength=this.curChunk.length,this.view=new DataView(this.curChunk.buffer),this.pos=0}nextByte(){const t=this.chunkLeft();if(!this.readable(t,1))throw new Error("No more bytes.");return 0===t&&this.nextChunk(),this.next()}readData(t,e){const r=this.chunkLeft();if(!this.readable(r,t))throw new Error("Not enough bytes.");if(0===r)this.nextChunk();else if(t>r){let s=this.views[t];return null==s&&(s=this.views[t]=new DataView(new ArrayBuffer(t))),this.loadTo(s,t,r),e(s,0,t)}const s=this.pos;return this.pos+=t,e(this.view,s,this.pos)}static getBytes(t,e,r){return new Uint8Array(t.buffer,e,r-e)}static getShort(t,e){return t.getUint16(e)}static getShorts(t,e,r){return new Uint16Array(t.buffer,e,(r-e)/2)}static getInt(t,e){return t.getInt32(e)}static getInts(t,e,r){return new Int32Array(t.buffer,e,(r-e)/4)}static getDouble(t,e){return t.getFloat64(e)}static getDoubles(t,e,r){return new Int64Array(t.buffer,e,(r-e)/8)}static getLong(t,e){return t.getInt32(e)}}class i{constructor(t){this.read=this.read.bind(this),this.data=new r(t),this.getByte=this.getByte.bind(this),this.getBytes=this.getBytes.bind(this),this.getShort=this.getShort.bind(this),this.getShorts=this.getShorts.bind(this),this.getInt=this.getInt.bind(this),this.getInts=this.getInts.bind(this),this.getDouble=this.getDouble.bind(this),this.getDoubles=this.getDoubles.bind(this),this.getLong=this.getLong.bind(this),this.getString=this.getString.bind(this),this.available=this.available.bind(this)}available(t=1){return this.iterator.available(t)}read(t,e){return this.data.read(e=>(this.iterator=e,t(this),this),e)}getByte(){return this.iterator.nextByte()}getBytes(t){return this.iterator.readData(t,s.getBytes)}getShort(){return this.iterator.readData(2,s.getShort)}getShorts(t){return this.iterator.readData(2*t,s.getShorts)}getInt(){return this.iterator.readData(4,s.getInt)}getInts(t){return this.iterator.readData(4*t,s.getInts)}getDouble(){return this.iterator.readData(8,s.getDouble)}getDoubles(t){return this.iterator.readData(8*t,s.getDoubles)}getLong(){return this.iterator.readData(8,s.getLong)}getString(t){return e.decodeUTF8(this.getBytes(t))}}class o{constructor(){this.pool=[],this.root={}}static read(t){return(new o).read(t)}read(t){return this.reader=new i(t),this.reader.read(this.readHeader.bind(this),6).then(()=>this)}async parse(t){try{return await this.load(t),this.root}catch(t){throw console.error(t),t}}readHeader(t){if(t!==this.reader)throw new Error("Unexpected reader in callback.");const e=t.getString(4);if("BIGV"!==e)throw new Error("Wrong file header magic: "+e);const r=t.getByte();if(r<6)throw new Error("Wrong file header version: "+e+":"+t.getByte());this.root.version={M:r,m:t.getByte()}}async load(t){this.root.groups=[],this.groups=[];try{let e;for(;this.reader.available();)e=this.readRoot(),void 0!==t&&(t(e),t=void 0);if(void 0!==this.curGroup||this.groups.length>0)throw new Error("Unexpected end of data.")}catch(t){throw this.groups.length>0?this.root.unloaded=this.groups[0]:this.root.unloaded=this.curGroup,this.curGroup=void 0,this.groups=void 0,console.log(this.root),this.root=void 0,t}if(this.curGroup=void 0,0!==this.groups.length){const t=this.groups;throw this.groups=void 0,new Error("Groups not ended properly: "+t)}}readRoot(){let t=this.reader.getByte();switch(t){case o.DEF.CONTROL.STREAM_PROPERTIES:return this.root.props=this.readDocument();case o.DEF.CONTROL.BEGIN_GROUP:const e=this.readGroup();return void 0!==this.curGroup&&(void 0===this.curGroup.groups&&(this.curGroup.groups=[]),this.curGroup.groups.push(e),this.groups.push(this.curGroup)),this.curGroup=e,e;case o.DEF.CONTROL.CLOSE_GROUP:const r=this.groups.pop();return void 0===r&&this.root.groups.push(this.curGroup),this.curGroup=r,"Group end.";case o.DEF.CONTROL.BEGIN_GRAPH:const s=this.readGraph();return void 0===this.curGroup.graphs&&(this.curGroup.graphs=[]),this.curGroup.graphs.push(s),s;case void 0:return"empty";default:throw new Error("Unknown control type: "+t)}}readDocument(){return this.readProperties()}readProperties(){const t=this.reader.getShort(),e={};for(let r=0;r<t;++r){let t=this.readPoolObject(o.DEF.POOL.STRING),r=this.readPropertyObject(t);e[t]=r}return e}readPoolObject(t){const e=this.reader.getByte();if(e===o.DEF.POOL.NULL)return null;if(e===o.DEF.POOL.NEW)return this.addPoolEntry(t);if(null!==t&&e!==t)throw new Error("Readed unexpected type: "+e+" expected: "+t);const r=this.reader.getShort(),s=this.pool[r];if(s.type!==e)throw new Error("Loaded unexpected pool type: "+s.type+" expected: "+e+" at index: "+r);return s.value}addPoolEntry(t=null){let e,r=this.reader.getShort(),s=this.reader.getByte();if(null!==t&&s!==t)throw new Error("Readed unexpected type: "+s+" expected: "+t+" at index: "+r);switch(s){case o.DEF.POOL.STRING:e=this.readString();break;case o.DEF.POOL.NODE_CLASS:e=this.readNodeClass();break;case o.DEF.POOL.CLASS:e=this.readClass();break;case o.DEF.POOL.ENUM:e=this.readEnum();break;case o.DEF.POOL.METHOD:e=this.readMethod();break;case o.DEF.POOL.FIELD:e=this.readField();break;case o.DEF.POOL.SIGNATURE:e=this.readSignature();break;case o.DEF.POOL.NODE_SOURCE_POSITION:e=this.readNodeSourcePosition();break;default:throw new Error("Unknown pool entry type: "+s+" with index: "+r)}return this.pool[r]={type:s,value:e},e}readString(){return this.reader.getString(this.reader.getInt())}readBytes(){return this.reader.getBytes(this.reader.getInt())}readInts(){return this.reader.getInts(this.reader.getInt())}readDoubles(){return this.reader.getDoubles(this.reader.getInt())}readPropertyObject(t=null){const e=this.reader.getByte();switch(e){case o.DEF.PROP.POOL:return this.readPoolObject(null);case o.DEF.PROP.DOUBLE:return this.reader.getDouble();case o.DEF.PROP.LONG:return this.reader.getLong();case o.DEF.PROP.INT:return this.reader.getInt();case o.DEF.PROP.TRUE:return!0;case o.DEF.PROP.FALSE:return!1;case o.DEF.PROP.ARRAY:return this.readArray();default:throw new Error("Unknown property type: "+e)}}readGroup(){const t={};return t.name=this.readPoolObject(o.DEF.POOL.STRING),t.shortName=this.readPoolObject(o.DEF.POOL.STRING),t.method=this.readPoolObject(o.DEF.POOL.METHOD),t.bci=this.reader.getInt(),t.props=this.readProperties(),t}readGraph(){const t={};t.id=this.reader.getInt(),t.format=this.readString();const e=this.reader.getInt();t.args=new Array(e);for(let r=0;r<e;++r)t.args[r]=this.readPropertyObject();return t.props=this.readProperties(),t.nodes=this.readNodes(),t.blocks=this.readBlocks(),t}readNodes(){const t=this.reader.getInt(),e=new Array(t);for(let r=0;r<t;++r)e[r]=this.readNode();return e}readNode(){const t={};return t.id=this.reader.getInt(),t.nodeClass=this.readPoolObject(o.DEF.POOL.NODE_CLASS),t.preds=this.reader.getByte(),t.props=this.readProperties(),t.inputs=[],this.readEdges(t.nodeClass.inputs,e=>t.inputs.push(e)),t.outputs=[],this.readEdges(t.nodeClass.suxs,e=>t.outputs.push(e)),t}readNodeClass(){const t={};t.klass=this.readPoolObject(o.DEF.POOL.CLASS),t.nameTemplate=this.readString();const e=this.reader.getShort();t.inputs=new Array(e);for(let r=0;r<e;++r){const e={};e.isList=0!==this.reader.getByte(),e.name=this.readPoolObject(o.DEF.POOL.STRING),e.inputType=this.readPoolObject(o.DEF.POOL.ENUM),t.inputs[r]=e}const r=this.reader.getShort();t.suxs=new Array(r);for(let e=0;e<r;++e){const r={};r.isList=0!==this.reader.getByte(),r.name=this.readPoolObject(o.DEF.POOL.STRING),t.suxs[e]=r}return t}readClass(){const t={};if(t.name=this.readString(),t.classType=this.reader.getByte(),t.classType===o.DEF.CLS.ENUM){const e=this.reader.getInt();t.values=new Array(e);for(let r=0;r<e;++r)t.values[r]=this.readPoolObject(o.DEF.POOL.STRING)}else if(t.classType!==o.DEF.CLS.CLASS)throw new Error("Unknown Klass type: "+t.classType);return t}readEnum(){const t={};return t.enumClass=this.readPoolObject(o.DEF.POOL.CLASS),t.ordinal=this.reader.getInt(),t}readMethod(){const t={};return t.holder=this.readPoolObject(o.DEF.POOL.CLASS),t.name=this.readPoolObject(o.DEF.POOL.STRING),t.signature=this.readPoolObject(o.DEF.POOL.SIGNATURE),t.flags=this.reader.getInt(),t.code=this.readBytes(),t}readSignature(){const t={},e=this.reader.getShort();t.args=[];for(let r=0;r<e;++r)t.args.push(this.readPoolObject(o.DEF.POOL.STRING));return t.returnType=this.readPoolObject(o.DEF.POOL.STRING),t}readBlocks(){const t=this.reader.getInt(),e=new Array(t);for(let r=0;r<t;++r)e[r]=this.readBlock();return e}readBlock(){const t={};t.id=this.reader.getInt();const e=this.reader.getInt();t.nodes=new Array(e);for(let r=0;r<e;++r)t.nodes[r]=this.reader.getInt();const r=this.reader.getInt();t.edges=new Array(r);for(let e=0;e<r;++e)t.edges[e]=this.reader.getInt();return t}readEdges(t,e){for(const r of t){const t=[];if(r.isList){const r=this.reader.getShort();for(let e=0;e<r;++e)t.push(this.reader.getInt());e(t)}else e(this.reader.getInt())}}readNodeSourcePosition(){const t={};for(t.method=this.readPoolObject(o.DEF.POOL.METHOD),t.bci=this.reader.getInt(),t.infos=[];;){const e=this.readPoolObject(o.DEF.POOL.STRING);if(null===e)break;const r={};r.uri=e,r.language=this.readString(),r.line=this.reader.getInt(),r.startOffset=this.reader.getInt(),r.endOffset=this.reader.getInt(),t.infos.push(r)}return t.parent=this.readPoolObject(o.DEF.POOL.NODE_SOURCE_POSITION),t}readArray(){const t=this.reader.getByte();switch(t){case o.DEF.PROP.INT:return this.readInts();case o.DEF.PROP.DOUBLE:return this.readDoubles();case o.DEF.PROP.POOL:return this.readPoolObjects();default:throw new Error("Unknown Array subType: "+t)}}readPoolObjects(){const t=this.reader.getInt();if(t<0)return null;const e=[];for(let r=0;r<t;++r)e.push(this.readPoolObject(null));return e}readField(){const t={};return t.holder=this.readPoolObject(o.DEF.POOL.CLASS),t.name=this.readPoolObject(o.DEF.POOL.STRING),t.fType=this.readPoolObject(o.DEF.POOL.STRING),t.flags=this.reader.getInt(),t}}return o.DEF=Object.freeze({CONTROL:Object.freeze({BEGIN_GROUP:0,BEGIN_GRAPH:1,CLOSE_GROUP:2,STREAM_PROPERTIES:3}),CLS:Object.freeze({CLASS:0,ENUM:1}),POOL:Object.freeze({NEW:0,STRING:1,ENUM:2,CLASS:3,METHOD:4,NULL:5,NODE_CLASS:6,FIELD:7,SIGNATURE:8,NODE_SOURCE_POSITION:9,NODE:10}),PROP:Object.freeze({POOL:0,INT:1,LONG:2,DOUBLE:3,FLOAT:4,TRUE:5,FALSE:6,ARRAY:7,SUBGRAPH:8})}),o}));