define(["app/tree-map","ojs/ojlogger"],(function(e,t){class o{static parse(e,s,r){const a=new o._formats[s];try{return a.parse(e,r)}catch(o){t.error(o),alert("Unable to parse file: "+e)}return null}get shortName(){throw new TypeError("Format is abstract and does not implement the shortName() method.")}get longName(){throw new TypeError("Format is abstract and does not implement the longName() method.")}get description(){throw new TypeError("Format is abstract and does not implement the description() method.")}get sections(){throw new TypeError("Format is abstract and does not implement the sections() method.")}parse(e,t,o){throw new TypeError("Format is abstract and does not implement the parse() method.")}static get defaultFormat(){return o._formats.NativeImageFormat.name}static get formats(){return Object.keys(o._formats)}static create(e){return new o._formats[e]}}return o._formats={NativeImageFormat:class extends o{get shortName(){return"Native Image"}get longName(){return"Native Image Dump Format"}get description(){return"File dumped by a native-image build, which contains details about the image."}get sections(){return{"code-breakdown":{title:"Code Size Breakdown",component:"x-tree-map-histogram"},"heap-breakdown":{title:"Heap Size Breakdown",component:"x-tree-map-histogram"},"points-to":{title:"Points-To Exploration",component:"x-points-to-exploration"}}}parse(e,t){return(e.endsWith("bgv")?this.parseBGV(e,t):Promise.resolve(JSON.parse(t))).then(e=>("heap-breakdown"in e&&(e["heap-breakdown"].treeMap=this.makeTreeMap(e["heap-breakdown"]["heap-size"])),"code-breakdown"in e&&(e["code-breakdown"].treeMap=this.makeTreeMap(e["code-breakdown"]["code-size"])),void 0!==e["points-to"]&&this._processPointsTo(e["points-to"]),e))}makeTreeMap(t){return new e(t)}parseBGV(e,t){return t.parse(this.validate(Object.keys(this.sections))).then(this.bgvToJSON.bind(this)).catch(t=>{throw console.error(t),alert("Unable to parse file: "+e),t})}validate(e){return t=>{if(!e.some(e=>t.name==e))throw new Error("No valid property header.")}}bgvToJSON(e){const t={},o=e.groups.find(e=>"points-to"===e.name);void 0!==o&&(t["points-to"]={"type-flows":this.getFlows(o)});const s=e.groups.find(e=>"heap-breakdown"===e.name);void 0!==s&&(t["heap-breakdown"]={"heap-size":this.getHeaps(s)});const r=e.groups.find(e=>"code-breakdown"===e.name);return void 0!==r&&(t["code-breakdown"]={"code-size":this.getCodes(r)}),t}getHeaps(e){const t=[];for(const[o,s]of Object.entries(e.props))t.push({name:o,size:Number.parseInt(s[0]),count:Number.parseInt(s[1])});return t}getFlows(e){const t=e.graphs[0];if(void 0===t)throw new Error("Faulty data.");const o=[];for(const e of t.nodes){const t={inputs:e.inputs,uses:e.outputs},s={id:e.id,flowType:e.props.flowType,info:t};t.qualifiedNameSimpleParams=e.props.qualifiedNameSimpleParams,t.qualifiedName=e.nodeClass.nameTemplate,t.codeLocation=e.props.codeLocation,t.calleeNames=e.props.calleeNames,t.enclosingMethod=e.props.enclosingMethod,o.push(s)}return o}getCodes(e){const t=[];for(const[o,s]of Object.entries(e.props))t.push({name:o,size:Number.parseInt(s)});return t}_processHistogramData(e){const o=[],s=new Map;return 0===e.length&&t.error("Empty histogram, can't create data structure."),e.forEach(e=>{if(e instanceof Array);else{let t,r=o;const a=e.size;e.name.split(".").forEach(e=>{t=t?t+"."+e:e;let o=s.get(t);o?o.size+=a:(o={label:t,size:a,nodes:[]},s.set(t,o),r.push(o)),r=o.nodes})}}),o}_processPointsTo(e){let t={},o={};e["type-flows"].forEach(e=>{t[e.id]=e,"method"===e.flowType&&(o[e.info.qualifiedNameSimpleParams]=e.id)}),e.pointsToGraph=this._skipIrrelevantNodes(t),e.methodNameIndex=o}_skipIrrelevantNodes(e){this.skippableFlowTypes=["nullCheck"];const t=(e,t)=>{for(;e.indexOf(t)>-1;)e.splice(e.indexOf(t),1)},o=Object.keys(e),s={},r={};return o.forEach(e=>{s[e]=!1}),o.forEach(o=>{const a=e[o];if(!this.skippableFlowTypes.includes(a.flowType))return void(r[o]=e[o]);s[o]=!0;const n=[],i=[];a.info.inputs.forEach(t=>{s[t]||n.push(e[t])}),a.info.uses.forEach(t=>{s[t]||i.push(e[t])}),i.forEach(e=>{t(e.info.inputs,a.id),n.forEach(t=>{const o=t.id;e.info.inputs.includes(o)||e.info.inputs.push(o)})}),n.forEach(e=>{t(e.info.uses,a.id),i.forEach(t=>{const o=t.id;e.info.uses.includes(o)||e.info.uses.push(o)})})}),r}}},o}));