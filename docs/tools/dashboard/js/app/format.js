"use strict";define(["app/tree-map","ojs/ojlogger"],(function(e,t){class o{static parse(e,r,s){const n=new o._formats[r];try{return n.parse(e,s)}catch(o){t.error(o),alert("Unable to parse file: "+e)}return null}get shortName(){throw new TypeError("Format is abstract and does not implement the shortName() method.")}get longName(){throw new TypeError("Format is abstract and does not implement the longName() method.")}get description(){throw new TypeError("Format is abstract and does not implement the description() method.")}get sections(){throw new TypeError("Format is abstract and does not implement the sections() method.")}parse(e,t,o){throw new TypeError("Format is abstract and does not implement the parse() method.")}static get defaultFormat(){return o._formats.NativeImageFormat.name}static get formats(){return Object.keys(o._formats)}static create(e){return new o._formats[e]}}return o._formats={NativeImageFormat:class extends o{get shortName(){return"Native Image"}get longName(){return"Native Image Dump Format"}get description(){return"File dumped by a native image builder, which contains details about the image."}get sections(){return{"code-breakdown":{title:"Code Size Breakdown",component:"x-tree-map-histogram"},"heap-breakdown":{title:"Heap Size Breakdown",component:"x-tree-map-histogram"},"points-to":{component:"x-points-to-exploration"}}}parse(t,o){return(t.endsWith("bgv")?this.parseBGV(t,o):Promise.resolve(JSON.parse(o))).then(t=>{const o={};return"heap-breakdown"in t&&this.lazy(o,"heap-breakdown",(function(t){return{treeMap:new e(t)}}),t["heap-breakdown"]["heap-size"]),"code-breakdown"in t&&this.lazy(o,"code-breakdown",(function(t){return{treeMap:new e(t)}}),t["code-breakdown"]["code-size"]),"points-to"in t&&this.lazy(o,"points-to",function(e){return this._processPointsTo(e)}.bind(this),t["points-to"]),o})}lazy(e,t,o,r){e[t]=function(){const s=o(r);return e[t]=function(){return s},s}}parseBGV(e,t){return t.parse(this.validate(Object.keys(this.sections))).then(this.bgvToJSON.bind(this)).catch(t=>{throw console.error(t),alert("Unable to parse file: "+e),t})}validate(e){return t=>{if(!e.some(e=>t.name==e))throw new Error("No valid property header.")}}bgvToJSON(e){const t={},o=e.groups.find(e=>"points-to"===e.name);void 0!==o&&(t["points-to"]={"type-flows":this.getFlows(o)});const r=e.groups.find(e=>"heap-breakdown"===e.name);void 0!==r&&(t["heap-breakdown"]={"heap-size":this.getHeaps(r)});const s=e.groups.find(e=>"code-breakdown"===e.name);return void 0!==s&&(t["code-breakdown"]={"code-size":this.getCodes(s)}),t}getHeaps(e){const t=[];for(const[o,r]of Object.entries(e.props))t.push({name:o,size:Number.parseInt(r[0]),count:Number.parseInt(r[1])});return t}getFlows(e){const t=e.graphs[0];if(void 0===t)throw new Error("Faulty data.");const o=[];for(const e of t.nodes){const t={inputs:e.inputs,uses:e.outputs},r={id:e.id,flowType:e.props.flowType,info:t};t.qualifiedNameSimpleParams=e.props.qualifiedNameSimpleParams,t.qualifiedName=e.nodeClass.nameTemplate,t.codeLocation=e.props.codeLocation,t.calleeNames=e.props.calleeNames,t.enclosingMethod=e.props.enclosingMethod,o.push(r)}return o}getCodes(e){const t=[];for(const[o,r]of Object.entries(e.props))t.push({name:o,size:Number.parseInt(r)});return t}_processHistogramData(e){const o=[],r=new Map;return 0===e.length&&t.error("Empty histogram, can't create data structure."),e.forEach(e=>{if(e instanceof Array);else{let t,s=o;const n=e.size;e.name.split(".").forEach(e=>{t=t?t+"."+e:e;let o=r.get(t);o?o.size+=n:(o={label:t,size:n,nodes:[]},r.set(t,o),s.push(o)),s=o.nodes})}}),o}_processPointsTo(e){const t={},o={},r={};return e["type-flows"].forEach(e=>{o[e.id]=e,"method"===e.flowType&&(r[e.info.qualifiedNameSimpleParams]=e.id)}),t.pointsToGraph=this._skipIrrelevantNodes(o),t.methodNameIndex=r,t}_skipIrrelevantNodes(e){this.skippableFlowTypes=["nullCheck"];const t=(e,t)=>{for(;e.indexOf(t)>-1;)e.splice(e.indexOf(t),1)},o=Object.keys(e),r={},s={};return o.forEach(e=>{r[e]=!1}),o.forEach(o=>{const n=e[o];if(!this.skippableFlowTypes.includes(n.flowType))return void(s[o]=e[o]);r[o]=!0;const a=[],i=[];n.info.inputs.forEach(t=>{r[t]||a.push(e[t])}),n.info.uses.forEach(t=>{r[t]||i.push(e[t])}),i.forEach(e=>{t(e.info.inputs,n.id),a.forEach(t=>{const o=t.id;e.info.inputs.includes(o)||e.info.inputs.push(o)})}),a.forEach(e=>{t(e.info.uses,n.id),i.forEach(t=>{const o=t.id;e.info.uses.includes(o)||e.info.uses.push(o)})})}),s}}},o}));